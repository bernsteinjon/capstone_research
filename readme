README for TurtleBot3 Navigation Code

Dependencies:

ROS Melodic:
http://wiki.ros.org/melodic/Installation/Ubuntu

BreezySLAM:
https://github.com/simondlevy/BreezySLAM

File Name: client_final.py

  First, we set up a ZeroMQ socket for sending the LiDAR data to the
  server.

  Next, we set up a rospy.Subscriber to subscribe to the /scan topic.
  From the /scan topic, it reads any LaserScan objects, and passes them
  into a method called callback.

  In the callback method, we send the values from the LaserScan object to
  our server script for processing.

File Name: server_final.py

  _EPS, _NEXT_AXIS, _AXES2TUPLE, euler_from_matrix(), quaternion_matrix(),
  euler_from_quaternion() are methods from a library used for movement
  in Python 2. The reason we used them in this script is because ZeroMQ is
  only available in Python 3+. Rather than changing the entire server script
  to Python 2, we included the methods so it could still function in Python 3.
  These are essentially responsible for determining the angle the robot must
  move at next.

  The Node() class, astar(), and astarInit() are all methods from the A*
  pathfinding algorithm. You can manipulate values in astarInit() to manipulate
  the A* algorithm.

  The server works by first opening the connection to the server. We take in
  that data and convert it into data was can use. We then pass the new data
  into slam.update(), which is available through BreezySLAM. We also retrieve
  the current x, y, and theta from slam.getpos(), which is also available from
  BreezySLAM.

  The next step is to pass the map generated by BreezySLAM into the
  convertToObstacleMap() function, which was written by me. BreezySLAM returns
  a 2D array with each index containing some value between 0-255. These integers
  represent a color range of white-black in grayscale. They also represent
  the confidence the algorithm has that an obstacle is present at that
  corresponding location. The convertToObstacleMap() takes this map and converts
  it to a binary map of 1's and 0's by taking everything over a certain confidence
  level and converting it to a 1. Everything else is converted to a 0. This
  gives us a semi-accurate map of the obstacles present in the environment.

  viz.display() is used to visualize the map we have generated.

  Then we generate a path using parameters we generated and passing them
  into the A* algorithm.

  After generating the map, we have to convert that to meters to move from
  the current position in the x and y direction, which is handled by the
  convertPath() method. Finally, we construct a message to move the robot
  and send over the /cmd_vel topic. This is done by moveRobot().

  This process is repeated until the robot reaches the final point in
  the generated path.
